{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@intrnl+velvet@0.5.0/node_modules/@intrnl/velvet/dist/esm/context-b031f67c.js", "../../src/generator.js", "../../src/App.velvet"],
  "sourcesContent": ["function html(fragment, is_wrapped) {\n  let node = document.createElement(\"template\");\n  node.innerHTML = fragment;\n  if (is_wrapped) {\n    let content = node.content;\n    let wrapper = content.firstChild;\n    let child;\n    wrapper.remove();\n    while (child = wrapper.firstChild) {\n      content.appendChild(child);\n    }\n  }\n  return node;\n}\nfunction create(element) {\n  return document.createElement(element);\n}\nfunction clone(template) {\n  let fragment = document.importNode(template.content, true);\n  return fragment;\n}\nfunction traverse(node, indices) {\n  let ref = node;\n  let i = 0;\n  let il = indices.length;\n  let x;\n  let j;\n  for (; i < il; i++) {\n    x = indices[i];\n    ref = ref.firstChild;\n    for (j = 0; j < x; j++) {\n      ref = ref.nextSibling;\n    }\n  }\n  return ref;\n}\nfunction replace(ref, node, adopt) {\n  ref.replaceWith(node);\n  if (adopt) {\n    let child;\n    while (child = ref.firstChild) {\n      node.appendChild(child);\n    }\n  }\n}\nfunction append(ref, node) {\n  ref.append(node);\n}\nfunction after(ref, node) {\n  ref.after(node);\n}\nfunction remove_parts(a, b) {\n  let node = a;\n  if (b.nextSibling === a) {\n    return;\n  }\n  while (node) {\n    let curr = node;\n    node = node.nextSibling;\n    curr.remove();\n    if (curr === b) {\n      break;\n    }\n  }\n}\nfunction on(node, type, listener, options) {\n  node.addEventListener(type, listener, options);\n}\nfunction toggle(node, name, value) {\n  node.toggleAttribute(name, value);\n}\nfunction attr(node, name, value) {\n  node.setAttribute(name, value);\n}\nfunction attr_ifdef(node, name, value) {\n  let map = node.$ifd || (node.$ifd = {});\n  let def = value != null;\n  if (def) {\n    attr(node, name, value);\n  } else if (map[name]) {\n    node.removeAttribute(name);\n  }\n  map[name] = def;\n}\nfunction class_toggle(node, name, value) {\n  node.classList.toggle(name, value);\n}\nfunction style_set(node, name, value) {\n  node.style.setProperty(name, value);\n}\nfunction get_checked_values(array, value, checked) {\n  let next = array.slice();\n  if (checked) {\n    next.push(value);\n    return next;\n  } else {\n    let index = array.indexOf(value);\n    if (index > -1) {\n      next.splice(index, 1);\n      return next;\n    }\n  }\n  return array;\n}\nfunction get_select_values(select) {\n  let multiple = select.multiple;\n  let array = [];\n  let selected = select.selectedOptions;\n  for (let i = 0, l = selected.length; i < l; i++) {\n    let option = selected[i];\n    array.push(option.value);\n  }\n  return multiple ? array : array[0];\n}\nfunction set_select_values(select, current) {\n  let multiple = select.multiple;\n  let options = select.options;\n  for (let i = 0, l = options.length; i < l; i++) {\n    let option = options[i];\n    let selected = multiple ? current.includes(option.value) : option.value === current;\n    option.selected = selected;\n    if (selected && !multiple) {\n      return;\n    }\n  }\n}\n\nlet _Object = Object;\nlet _Symbol = Symbol;\n\nlet RE_HYPHENATE = /\\B([A-Z])/g;\nlet noop = () => {\n};\nfunction hyphenate(str) {\n  return str.replace(RE_HYPHENATE, \"-$1\").toLowerCase();\n}\nlet is = _Object.is;\nlet assign = _Object.assign;\nlet is_function = (x) => typeof x === \"function\";\nfunction to_number(value) {\n  return value === \"\" ? null : +value;\n}\n\nlet undefined$1;\nlet RUNNING = 1 << 0;\nlet NOTIFIED = 1 << 1;\nlet OUTDATED = 1 << 2;\nlet DISPOSED = 1 << 3;\nlet HAS_ERROR = 1 << 4;\nlet TRACKING = 1 << 5;\nlet depth_sort = (a, b) => a.c - b.c;\nlet eval_scope;\nlet eval_context;\nlet eval_sources;\nlet eval_sources_idx = 0;\nlet batched_effects;\nlet batch_depth = 0;\nlet batch_iteration = 0;\nlet clock = 0;\nfunction start_batch() {\n  batch_depth++;\n}\nfunction end_batch() {\n  if (batch_depth > 1) {\n    batch_depth--;\n    return;\n  }\n  let error;\n  let has_error = false;\n  while (batched_effects) {\n    let effects = batched_effects.sort(depth_sort);\n    let idx = 0;\n    let len = effects.length;\n    batched_effects = undefined$1;\n    batch_iteration++;\n    for (; idx < len; idx++) {\n      let effect2 = effects[idx];\n      effect2.d &= ~NOTIFIED;\n      if (!(effect2.d & DISPOSED) && need_recompute(effect2)) {\n        try {\n          effect2.m();\n        } catch (err) {\n          if (!has_error) {\n            error = err;\n            has_error = true;\n          }\n        }\n      }\n    }\n  }\n  batch_iteration = 0;\n  batch_depth--;\n  if (has_error) {\n    throw error;\n  }\n}\nfunction need_recompute(target) {\n  let sources = target.b;\n  let len = sources.length;\n  let idx = 0;\n  let source;\n  for (; idx < len; idx++) {\n    source = sources[idx];\n    if (source.e > target.e || source.h()) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction cleanup_context() {\n  let sources = eval_context.b;\n  if (eval_sources) {\n    prune_context_sources();\n    if (eval_sources_idx > 0) {\n      let l = eval_sources.length;\n      let i = 0;\n      sources.length = eval_sources_idx + l;\n      for (; i < l; i++) {\n        sources[eval_sources_idx + i] = eval_sources[i];\n      }\n    } else {\n      sources = eval_context.b = eval_sources;\n    }\n    let len = sources.length;\n    let idx = eval_sources_idx;\n    for (; idx < len; idx++) {\n      let source = sources[idx];\n      source.i = undefined$1;\n      if (eval_context.d & TRACKING) {\n        source.j(eval_context);\n      }\n    }\n  } else if (eval_sources_idx < eval_context.b.length) {\n    prune_context_sources();\n    sources.length = eval_sources_idx;\n  }\n  while (eval_sources_idx--) {\n    let source = sources[eval_sources_idx];\n    source.i = undefined$1;\n  }\n}\nfunction prune_context_sources() {\n  let sources = eval_context.b;\n  let len = sources.length;\n  let idx = eval_sources_idx;\n  for (; idx < len; idx++) {\n    let source = sources[idx];\n    source.g(eval_context);\n  }\n}\nfunction dispose_effect(effect2) {\n  let sources = effect2.b;\n  let len = sources.length;\n  let idx = 0;\n  for (; idx < len; idx++) {\n    sources[idx].g(effect2);\n  }\n  sources.length = 0;\n}\nclass Signal {\n  /**\n   * @param {T} value\n   */\n  constructor(value) {\n    let _this = this;\n    _this.a = value;\n    _this.e = -1;\n    _this.f = [];\n    _this.i = undefined$1;\n  }\n  /**\n   * @internal\n   * @returns {boolean}\n   */\n  h() {\n    return false;\n  }\n  /**\n   * @internal\n   * @param {Computed | Effect} target\n   */\n  j(target) {\n    let _this = this;\n    _this.f.push(target);\n  }\n  /**\n   * @internal\n   * @param {Computed | Effect} target\n   */\n  g(target) {\n    let _this = this;\n    let targets = _this.f;\n    let idx = targets.indexOf(target);\n    targets.splice(idx, 1);\n  }\n  /**\n   * @returns {T}\n   */\n  peek() {\n    let _this = this;\n    return _this.a;\n  }\n  /** @type {T} */\n  get value() {\n    let _this = this;\n    if (eval_context && _this.i !== eval_context) {\n      _this.i = eval_context;\n      if (!eval_sources) {\n        if (eval_context.b[eval_sources_idx] === _this) {\n          eval_sources_idx++;\n        } else {\n          eval_sources = [_this];\n        }\n      } else {\n        eval_sources.push(_this);\n      }\n    }\n    return _this.a;\n  }\n  set value(next) {\n    let _this = this;\n    if (_this.a !== next) {\n      _this.a = next;\n      _this.e = ++clock;\n      if (batch_iteration < 100) {\n        let targets = _this.f;\n        let len = targets.length;\n        let idx = 0;\n        start_batch();\n        for (; idx < len; idx++) {\n          targets[idx].k();\n        }\n        end_batch();\n      }\n    }\n  }\n}\nclass Computed extends Signal {\n  /**\n   * @param {() => T} compute\n   */\n  constructor(compute) {\n    super();\n    let _this = this;\n    _this.l = compute;\n    _this.b = [];\n    _this.d = OUTDATED;\n    _this.n = -1;\n  }\n  /**\n   * @internal\n   * @returns {boolean}\n   */\n  h() {\n    let _this = this;\n    _this.d &= ~NOTIFIED;\n    if (_this.d & RUNNING) {\n      return false;\n    }\n    if ((_this.d & (OUTDATED | TRACKING)) === TRACKING) {\n      return false;\n    }\n    _this.d &= ~OUTDATED;\n    if (_this.n === clock) {\n      return false;\n    }\n    _this.n = clock;\n    _this.d |= RUNNING;\n    if (_this.e > -1 && !need_recompute(_this)) {\n      _this.d &= ~RUNNING;\n      return false;\n    }\n    let stale = false;\n    let prev_context = eval_context;\n    let prev_sources = eval_sources;\n    let prev_sources_idx = eval_sources_idx;\n    try {\n      eval_context = _this;\n      eval_sources = undefined$1;\n      eval_sources_idx = 0;\n      let value = _this.l();\n      if (_this.d & HAS_ERROR || _this.a !== value || _this.e === -1) {\n        stale = true;\n        _this.a = value;\n        _this.d &= ~HAS_ERROR;\n        _this.e = ++clock;\n      }\n    } catch (err) {\n      stale = true;\n      _this.a = err;\n      _this.d |= HAS_ERROR;\n      _this.e = ++clock;\n    }\n    cleanup_context();\n    eval_context = prev_context;\n    eval_sources = prev_sources;\n    eval_sources_idx = prev_sources_idx;\n    _this.d &= ~RUNNING;\n    return stale;\n  }\n  /**\n   * @internal\n   * @param {Computed | Effect} target\n   */\n  j(target) {\n    let _this = this;\n    if (_this.f.length < 1) {\n      let sources = _this.b;\n      let len = sources.length;\n      let idx = 0;\n      _this.d |= TRACKING;\n      for (; idx < len; idx++) {\n        sources[idx].j(_this);\n      }\n    }\n    super.j(target);\n  }\n  /**\n   * @internal\n   * @param {Computed | Effect} target\n   */\n  g(target) {\n    let _this = this;\n    super.g(target);\n    if (_this.f.length < 1) {\n      let sources = _this.b;\n      let len = sources.length;\n      let idx = 0;\n      _this.d &= ~TRACKING;\n      for (; idx < len; idx++) {\n        sources[idx].g(_this);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  k() {\n    let _this = this;\n    if (!(_this.d & (NOTIFIED | RUNNING))) {\n      let targets = _this.f;\n      let len = targets.length;\n      let idx = 0;\n      _this.d |= OUTDATED | NOTIFIED;\n      for (; idx < len; idx++) {\n        targets[idx].k();\n      }\n    }\n  }\n  peek() {\n    let _this = this;\n    _this.h();\n    if (_this.d & HAS_ERROR) {\n      throw _this.a;\n    }\n    return _this.a;\n  }\n  get value() {\n    let _this = this;\n    _this.h();\n    if (_this.d & HAS_ERROR) {\n      throw super.value;\n    }\n    return super.value;\n  }\n  set value(next) {\n    super.value = next;\n  }\n}\nclass Effect {\n  /**\n   * @param {() => void} compute\n   */\n  constructor(compute) {\n    let _this = this;\n    _this.l = compute;\n    _this.e = 0;\n    _this.b = [];\n    _this.d = TRACKING;\n    _this.c = 0;\n  }\n  /**\n   * @internal\n   */\n  m() {\n    let _this = this;\n    if (_this.d & RUNNING) {\n      return;\n    }\n    _this.e = clock;\n    _this.d |= RUNNING;\n    _this.d &= ~OUTDATED;\n    let prev_context = eval_context;\n    let prev_sources = eval_sources;\n    let prev_sources_idx = eval_sources_idx;\n    try {\n      start_batch();\n      eval_context = _this;\n      eval_sources = undefined$1;\n      eval_sources_idx = 0;\n      _this.l();\n    } finally {\n      cleanup_context();\n      eval_context = prev_context;\n      eval_sources = prev_sources;\n      eval_sources_idx = prev_sources_idx;\n      _this.d &= ~RUNNING;\n      if (_this.d & DISPOSED) {\n        dispose_effect(_this);\n      }\n      end_batch();\n    }\n  }\n  /**\n   * @internal\n   */\n  k() {\n    let _this = this;\n    if (!(_this.d & (NOTIFIED | RUNNING))) {\n      _this.d |= OUTDATED | NOTIFIED;\n      (batched_effects ||= []).push(_this);\n    }\n  }\n  /**\n   * @internal\n   */\n  o() {\n    let _this = this;\n    _this.d |= DISPOSED;\n    if (!(_this.d & RUNNING)) {\n      dispose_effect(_this);\n    }\n  }\n}\nclass Scope {\n  /**\n   * @param {boolean} [detached]\n   */\n  constructor(detached) {\n    let _this = this;\n    _this.scopes = [];\n    _this.cleanups = [];\n    _this.parent = undefined$1;\n    _this.c = 0;\n    if (!detached && eval_scope) {\n      _this.parent = eval_scope;\n      _this.c = eval_scope.c + 1;\n      eval_scope.scopes.push(_this);\n    }\n  }\n  /**\n   * @template {T}\n   * @param {() => T} callback\n   * @returns {T}\n   */\n  run(callback) {\n    let prev_scope = eval_scope;\n    try {\n      eval_scope = this;\n      return callback();\n    } finally {\n      eval_scope = prev_scope;\n    }\n  }\n  clear() {\n    let _this = this;\n    let scopes = _this.scopes;\n    let cleanups = _this.cleanups;\n    for (let scope2 of scopes) {\n      scope2.clear();\n      scope2.parent = undefined$1;\n    }\n    for (let cleanup2 of cleanups) {\n      cleanup2();\n    }\n    scopes.length = 0;\n    cleanups.length = 0;\n  }\n}\nfunction scope(detached) {\n  return new Scope(detached);\n}\nfunction cleanup(callback) {\n  if (is_function(callback) && eval_scope) {\n    eval_scope.cleanups.push(callback);\n  }\n}\nfunction batch(callback) {\n  if (batch_depth > 0) {\n    return callback();\n  }\n  start_batch();\n  try {\n    return callback();\n  } finally {\n    end_batch();\n  }\n}\nfunction untrack(callback) {\n  let prev_context = eval_context;\n  try {\n    eval_context = undefined$1;\n    return callback();\n  } finally {\n    eval_context = prev_context;\n  }\n}\nfunction peek(value) {\n  if (value instanceof Signal) {\n    return value.peek();\n  }\n  return value;\n}\nfunction signal(value) {\n  return new Signal(value);\n}\nfunction computed(compute) {\n  return new Computed(compute);\n}\nfunction effect(compute) {\n  let effect2 = new Effect(compute);\n  let dispose = effect2.o.bind(effect2);\n  try {\n    effect2.m();\n  } catch (error) {\n    dispose();\n    throw error;\n  }\n  if (eval_scope && effect2.b.length > 0) {\n    effect2.c = eval_scope.c;\n    eval_scope.cleanups.push(dispose);\n  }\n  return dispose;\n}\n\nlet ENABLE_RANDOM_TAGS = false;\nlet RANDOM_TAG = 1;\nfunction use_random_tags() {\n  ENABLE_RANDOM_TAGS = true;\n}\nlet curr_host = null;\nlet default_value = _Symbol();\nclass VelvetComponent extends HTMLElement {\n  // static $c: setup function\n  // static $a: attr to prop definition\n  // static $d: prop definitions\n  // static $s: stylesheets\n  /** is mounted */\n  $m = false;\n  /** scope instance */\n  $c = scope(true);\n  /** @type {Record<number, Signal>} props */\n  $p = {};\n  /** on mount hooks */\n  $h = [];\n  constructor() {\n    super();\n    let host = this;\n    let props = host.$p;\n    let definition = host.constructor.$d;\n    for (let prop2 in definition) {\n      let index = definition[prop2];\n      props[index] = signal(default_value);\n    }\n  }\n  connectedCallback() {\n    let host = this;\n    if (!host.$m) {\n      host.$m = true;\n      let setup = host.constructor.$c;\n      let styles = host.constructor.$s;\n      let instance = host.$c;\n      let hooks = host.$h;\n      let root = host.shadowRoot;\n      let init_ccss = false;\n      if (!root) {\n        root = host.attachShadow({ mode: \"open\" });\n        init_ccss = true;\n      }\n      let prev_host = curr_host;\n      try {\n        curr_host = host;\n        instance.run(() => setup(root, host));\n        if (document.adoptedStyleSheets) {\n          if (init_ccss) {\n            root.adoptedStyleSheets = styles;\n          }\n        } else {\n          for (let style of styles) {\n            append(root, style.cloneNode(true));\n          }\n        }\n        for (let hook of hooks) {\n          let ret = hook();\n          if (is_function(ret)) {\n            instance.cleanups.push(ret);\n          }\n        }\n        hooks.length = 0;\n      } finally {\n        curr_host = prev_host;\n      }\n    }\n  }\n  disconnectedCallback() {\n    let host = this;\n    if (host.$m) {\n      host.$c.clear();\n      host.shadowRoot.innerHTML = \"\";\n      host.$m = false;\n    }\n  }\n  attributeChangedCallback(attr, prev, next) {\n    let host = this;\n    let mapping = host.constructor.$d;\n    if (attr in mapping) {\n      host.$p[mapping[attr]].value = next === \"\" ? true : next;\n    }\n  }\n}\nfunction define(tag, setup, definition, styles) {\n  let observed_attrs = [];\n  let attr_to_prop = _Object.create(null);\n  class Component extends VelvetComponent {\n    static observedAttributes = observed_attrs;\n    static $c = setup;\n    static $a = attr_to_prop;\n    static $d = definition;\n    static $s = styles;\n  }\n  for (let prop2 in definition) {\n    let index = definition[prop2];\n    let hyphen = hyphenate(prop2);\n    attr_to_prop[hyphen] = prop2;\n    observed_attrs.push(hyphen);\n    _Object.defineProperty(Component.prototype, prop2, {\n      /** @this VelvetComponent */\n      get() {\n        return this.$p[index].a;\n      },\n      /** @this VelvetComponent */\n      set(next) {\n        this.$p[index].value = next;\n      }\n    });\n  }\n  if (ENABLE_RANDOM_TAGS) {\n    tag = \"velvet-\" + RANDOM_TAG++;\n  }\n  if (tag) {\n    customElements.define(tag, Component);\n  }\n  return Component;\n}\nfunction css(text) {\n  if (!document.adoptedStyleSheets) {\n    const style2 = document.createElement(\"style\");\n    style2.textContent = text;\n    return style2;\n  }\n  const style = new CSSStyleSheet();\n  style.replaceSync(text);\n  return style;\n}\nfunction prop(index, value) {\n  let state = curr_host.$p[index];\n  if (state.value === default_value) {\n    state.value = is_function(value) ? value() : value;\n  }\n  return state;\n}\nfunction on_mount(fn) {\n  if (is_function(fn)) {\n    curr_host.$h.push(fn);\n  }\n}\nfunction event_dispatcher() {\n  let host = curr_host;\n  return (type, detail) => {\n    let event = new CustomEvent(type, { detail, bubbles: false });\n    host.dispatchEvent(event);\n  };\n}\nfunction bind(obj) {\n  assign(curr_host, obj);\n}\nfunction use(node, action, getter) {\n  let ref = getter && computed(getter);\n  let instance = action(node, ref && ref.value);\n  if (!instance) {\n    return;\n  }\n  if (is_function(instance.destroy)) {\n    cleanup(() => instance.destroy());\n  }\n  if (ref && ref.b && is_function(instance.update)) {\n    let init = false;\n    effect(() => {\n      let next = ref.value;\n      if (!init) {\n        init = true;\n        return;\n      }\n      instance.update(next);\n    });\n  }\n}\n\nlet event_name = \"context-request\";\nfunction provide(key, value) {\n  let listener = (event) => {\n    if (event.context === key) {\n      event.stopImmediatePropagation();\n      event.callback(value, null);\n    }\n  };\n  on(curr_host, event_name, listener);\n}\nfunction inject(key, def) {\n  let value = def;\n  let callback = (next, dispose) => {\n    dispose?.();\n    value = next;\n  };\n  let event = new ContextEvent(key, callback, false);\n  curr_host.dispatchEvent(event);\n  return value;\n}\nclass ContextEvent extends Event {\n  constructor(context, callback, multiple) {\n    super(event_name, { bubbles: true, composed: true });\n    this.context = context;\n    this.callback = callback;\n    this.multiple = multiple;\n  }\n}\n\nexport { html as A, create as B, ContextEvent as C, clone as D, traverse as E, after as F, on as G, toggle as H, attr as I, attr_ifdef as J, class_toggle as K, style_set as L, get_checked_values as M, get_select_values as N, set_select_values as O, Computed as P, Effect as Q, noop as R, Scope as S, hyphenate as T, assign as U, VelvetComponent as V, is_function as W, to_number as X, computed as a, batch as b, cleanup as c, effect as d, event_dispatcher as e, peek as f, Signal as g, signal as h, inject as i, untrack as j, append as k, eval_scope as l, remove_parts as m, is as n, on_mount as o, provide as p, curr_host as q, replace as r, scope as s, default_value as t, use_random_tags as u, define as v, css as w, prop as x, bind as y, use as z };\n", "const RAND_MAX = 0xFFFF_FFFF_FFFF;\nconst RAND_CACHE = new Uint8Array(6 * 1024);\n\nlet RAND_OFFSET  = RAND_CACHE.length;\n\n/**\n * @param {PasswordGenerationOptions} options\n * @returns {string}\n */\nexport function generatePassword (options) {\n\tconst positions = [];\n\n\tfor (let i = 0, l = options.lowercase; i < l; i++) {\n\t\tpositions.push('l');\n\t}\n\n\tfor (let i = 0, l = options.uppercase; i < l; i++) {\n\t\tpositions.push('u');\n\t}\n\n\tfor (let i = 0, l = options.number; i < l; i++) {\n\t\tpositions.push('n');\n\t}\n\n\tfor (let i = 0, l = options.special; i < l; i++) {\n\t\tpositions.push('s');\n\t}\n\n\tfor (let i = positions.length; i < options.length; i++) {\n\t\tpositions.push('r');\n\t}\n\n\tshuffle(positions);\n\n\tlet charset = '';\n\n\tlet lowercaseCharset = 'abcdefghijkmnopqrstuvwxyz';\n\tlet uppercaseCharset = 'ABCDEFGHJKLMNPQRSTUVWXYZ';\n\tlet numberCharset = '23456789';\n\tlet specialCharset = '!@#$%^&*()_+-=.';\n\n\tif (options.ambiguous) {\n\t\tlowercaseCharset += 'l';\n\t\tuppercaseCharset += 'IO';\n\t\tnumberCharset += '10';\n\t}\n\n\tif (options.lowercase > -1) {\n\t\tcharset += lowercaseCharset;\n\t}\n\n\tif (options.uppercase > -1) {\n\t\tcharset += uppercaseCharset;\n\t}\n\n\tif (options.number > -1) {\n\t\tcharset += numberCharset;\n\t}\n\n\tif (options.special > -1) {\n\t\tcharset += specialCharset;\n\t}\n\n\tlet password = '';\n\n\tfor (let idx = 0; idx < positions.length; idx++) {\n\t\tlet selectedCharset;\n\n\t\tswitch (positions[idx]) {\n\t\t\tcase 'l':\n\t\t\t\tselectedCharset = lowercaseCharset;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tselectedCharset = uppercaseCharset;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tselectedCharset = numberCharset;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tselectedCharset = specialCharset;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tselectedCharset = charset;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpassword += selectedCharset[randrange(0, selectedCharset.length)];\n\t}\n\n\treturn password;\n}\n\n/**\n * https://stackoverflow.com/a/12646864\n * @param {any[]} array\n */\nfunction shuffle (array) {\n\tfor (let i = array.length - 1; i > 0; i--) {\n\t\tconst j = randrange(0, i);\n\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * @param {number} min\n * @param {number} max\n * @returns {number}\n */\nfunction randrange (min, max) {\n\tconst range = max - min;\n\n\tif (range <= 0) {\n\t\treturn min;\n\t}\n\n\tconst limit = RAND_MAX - (RAND_MAX % range);\n\n\twhile (true) {\n\t\tif (RAND_OFFSET === RAND_CACHE.length) {\n\t\t\tcrypto.getRandomValues(RAND_CACHE);\n\t\t\tRAND_OFFSET = 0;\n\t\t}\n\n\t\tconst x = readUInt48BE(RAND_CACHE, RAND_OFFSET);\n\t\tRAND_OFFSET += 6;\n\n\t\tif (x < limit) {\n\t\t\treturn (x % range) + min;\n\t\t}\n\t}\n}\n\n/**\n * @param {Uint8Array} buffer\n * @param {number} offset\n * @returns {number}\n */\nfunction readUInt48BE (buffer, offset = 0) {\n\tconst first = buffer[offset];\n\tconst last = buffer[offset + 5];\n\n\treturn (\n\t\t(first * 2 ** 8 + buffer[++offset]) * 2 ** 32 + buffer[++offset] * 2 ** 24 +\n\t\tbuffer[++offset] * 2 ** 16 + buffer[++offset] * 2 ** 8 + last\n\t);\n}\n\n/**\n * @typedef {object} PasswordGenerationOptions\n * @property {number} length Password length\n * @property {number} lowercase Include lowercase characters\n * @property {number} uppercase Include uppercase characters\n * @property {number} number Include number characters\n * @property {number} special Include special characters\n * @property {boolean} ambiguous Include potentially ambiguous characters\n */\n", "import {signal, html, clone, traverse, effect, attr, on, to_number, append, css, define} from \"@intrnl/velvet/internal\";\nimport {generatePassword} from './generator.js';\nimport '~/style.css';\nlet template0 = html(\"<h3>random password generator</h3><form><div class=password><input readonly><button type=button>copy</button><button type=submit>generate</button></div><hr><label><span>length</span> <input required type=number min=1></label><label><span>lowercase</span> <input required type=number min=-1></label><label><span>uppercase</span> <input required type=number min=-1></label><label><span>number</span> <input required type=number min=-1></label><label><span>special</span> <input required type=number min=-1></label><label><span>ambiguous</span> <input type=checkbox></label><hr><p><a target=_blank href=https://codeberg.org/intrnl/random-password-generator> source code </a></p></form>\");\nlet style0 = css(\"*,*:before,*:after{box-sizing:border-box}h3,form,label{margin-top:0;margin-bottom:16px}h3,form{display:block}label{display:flex;align-items:center;justify-content:space-between}label>span{display:block;margin-bottom:4px;flex-grow:1}input,button{padding:8px;height:36px}input{font-family:monospace}.password{display:flex;gap:8px}.password input{width:-moz-available;width:-webkit-fill-available;width:fill-available}hr{color:transparent;border:0;border-bottom:1px solid #808080;margin:16px 0}a{text-decoration:none}a:hover{text-decoration:underline}\");\nfunction setup($$root, $$host) {\n  let length = signal(16);\n  let lowercase = signal(1);\n  let uppercase = signal(1);\n  let number = signal(1);\n  let special = signal(1);\n  let ambiguous = signal(false);\n  let password = signal('');\n  let textfield = signal();\n  function generate(ev) {\n    if (ev) {\n      ev.preventDefault();\n    }\n    password.value = generatePassword({\n      length: length.value,\n      lowercase: lowercase.value,\n      uppercase: uppercase.value,\n      number: number.value,\n      special: special.value,\n      ambiguous: ambiguous.value\n    });\n  }\n  function copy() {\n    textfield.value.select();\n    document.execCommand('copy');\n  }\n  generate();\n  let fragment0 = clone(template0);\n  let child0 = traverse(fragment0, [1, 0, 0]);\n  let child1 = traverse(fragment0, [1, 0, 1]);\n  let child2 = traverse(fragment0, [1, 2, 2]);\n  let child3 = traverse(fragment0, [1, 3, 2]);\n  let child4 = traverse(fragment0, [1, 4, 2]);\n  let child5 = traverse(fragment0, [1, 5, 2]);\n  let child6 = traverse(fragment0, [1, 6, 2]);\n  let child7 = traverse(fragment0, [1, 7, 2]);\n  let child8 = traverse(fragment0, [1]);\n  effect(() => attr(child0, \"value\", password.value));\n  textfield.value = child0;\n  on(child1, \"click\", copy);\n  effect(() => child2[\"value\"] = length.value);\n  on(child2, \"input\", () => length.value = to_number(child2.value));\n  effect(() => child3[\"value\"] = lowercase.value);\n  on(child3, \"input\", () => lowercase.value = to_number(child3.value));\n  effect(() => child4[\"value\"] = uppercase.value);\n  on(child4, \"input\", () => uppercase.value = to_number(child4.value));\n  effect(() => child5[\"value\"] = number.value);\n  on(child5, \"input\", () => number.value = to_number(child5.value));\n  effect(() => child6[\"value\"] = special.value);\n  on(child6, \"input\", () => special.value = to_number(child6.value));\n  effect(() => child7[\"checked\"] = ambiguous.value);\n  on(child7, \"input\", () => ambiguous.value = child7.checked);\n  on(child8, \"submit\", generate);\n  append($$root, fragment0);\n}\nexport default define(\"x-app\", setup, {}, [style0]);\n"],
  "mappings": "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",
  "names": ["html", "fragment", "is_wrapped", "node", "content", "wrapper", "child", "clone", "template", "traverse", "node", "indices", "ref", "i", "il", "x", "j", "append", "ref", "node", "on", "node", "type", "listener", "options", "attr", "node", "name", "value", "_Object", "_Symbol", "RE_HYPHENATE", "hyphenate", "str", "RE_HYPHENATE", "is", "_Object", "assign", "is_function", "x", "to_number", "value", "undefined$1", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "depth_sort", "a", "b", "eval_scope", "eval_context", "eval_sources", "eval_sources_idx", "batched_effects", "batch_depth", "batch_iteration", "clock", "start_batch", "end_batch", "error", "has_error", "effects", "idx", "len", "effect2", "need_recompute", "err", "target", "sources", "source", "cleanup_context", "prune_context_sources", "l", "i", "dispose_effect", "Signal", "_this", "targets", "next", "Effect", "compute", "_this", "TRACKING", "RUNNING", "clock", "OUTDATED", "prev_context", "eval_context", "prev_sources", "eval_sources", "prev_sources_idx", "eval_sources_idx", "start_batch", "undefined$1", "cleanup_context", "DISPOSED", "dispose_effect", "end_batch", "NOTIFIED", "batched_effects", "Scope", "detached", "eval_scope", "callback", "prev_scope", "scopes", "cleanups", "scope2", "cleanup2", "scope", "signal", "value", "Signal", "effect", "compute", "effect2", "Effect", "dispose", "error", "eval_scope", "ENABLE_RANDOM_TAGS", "RANDOM_TAG", "curr_host", "default_value", "_Symbol", "VelvetComponent", "scope", "host", "props", "definition", "prop2", "index", "signal", "setup", "styles", "instance", "hooks", "root", "init_ccss", "prev_host", "style", "append", "hook", "ret", "is_function", "attr", "prev", "next", "mapping", "define", "tag", "observed_attrs", "attr_to_prop", "_Object", "Component", "hyphen", "hyphenate", "ENABLE_RANDOM_TAGS", "RANDOM_TAG", "css", "text", "style2", "RAND_CACHE", "RAND_OFFSET", "generatePassword", "options", "positions", "i", "l", "shuffle", "charset", "lowercaseCharset", "uppercaseCharset", "numberCharset", "specialCharset", "password", "idx", "selectedCharset", "randrange", "array", "j", "temp", "min", "max", "range", "limit", "x", "readUInt48BE", "buffer", "offset", "first", "last", "template0", "html", "style0", "css", "setup", "$$root", "$$host", "length", "signal", "lowercase", "uppercase", "number", "special", "ambiguous", "password", "textfield", "generate", "ev", "generatePassword", "copy", "fragment0", "clone", "child0", "traverse", "child1", "child2", "child3", "child4", "child5", "child6", "child7", "child8", "effect", "attr", "on", "to_number", "append", "App_default", "define"]
}
