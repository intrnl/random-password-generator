{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@intrnl+velvet@0.4.22/node_modules/@intrnl/velvet/dist/esm/context-e0a096fc.js", "../../src/generator.js", "../../src/App.velvet"],
  "sourcesContent": ["function html(fragment, is_wrapped) {\n  let node = document.createElement(\"template\");\n  node.innerHTML = fragment;\n  if (is_wrapped) {\n    let content = node.content;\n    let wrapper = content.firstChild;\n    let child;\n    wrapper.remove();\n    while (child = wrapper.firstChild) {\n      content.appendChild(child);\n    }\n  }\n  return node;\n}\nfunction create(element) {\n  return document.createElement(element);\n}\nfunction clone(template) {\n  let fragment = document.importNode(template.content, true);\n  return fragment;\n}\nfunction traverse(node, indices) {\n  let ref = node;\n  let i = 0;\n  let il = indices.length;\n  let x;\n  let j;\n  for (; i < il; i++) {\n    x = indices[i];\n    ref = ref.firstChild;\n    for (j = 0; j < x; j++) {\n      ref = ref.nextSibling;\n    }\n  }\n  return ref;\n}\nfunction replace(ref, node, adopt) {\n  ref.replaceWith(node);\n  if (adopt) {\n    let child;\n    while (child = ref.firstChild) {\n      node.appendChild(child);\n    }\n  }\n}\nfunction append(ref, node) {\n  ref.append(node);\n}\nfunction after(ref, node) {\n  ref.after(node);\n}\nfunction remove_parts(a, b) {\n  let node = a;\n  if (b.nextSibling === a) {\n    return;\n  }\n  while (node) {\n    let curr = node;\n    node = node.nextSibling;\n    curr.remove();\n    if (curr === b) {\n      break;\n    }\n  }\n}\nfunction on(node, type, listener, options) {\n  node.addEventListener(type, listener, options);\n}\nfunction toggle(node, name, value) {\n  node.toggleAttribute(name, value);\n}\nfunction attr(node, name, value) {\n  node.setAttribute(name, value);\n}\nfunction attr_ifdef(node, name, value) {\n  let map = node.$ifd || (node.$ifd = {});\n  let def = value != null;\n  if (def) {\n    attr(node, name, value);\n  } else if (map[name]) {\n    node.removeAttribute(name);\n  }\n  map[name] = def;\n}\nfunction class_toggle(node, name, value) {\n  node.classList.toggle(name, value);\n}\nfunction style_set(node, name, value) {\n  node.style.setProperty(name, value);\n}\nfunction get_checked_values(array, value, checked) {\n  let next = array.slice();\n  if (checked) {\n    next.push(value);\n    return next;\n  } else {\n    let index = array.indexOf(value);\n    if (index > -1) {\n      next.splice(index, 1);\n      return next;\n    }\n  }\n  return array;\n}\nfunction get_select_values(select) {\n  let multiple = select.multiple;\n  let array = [];\n  let selected = select.selectedOptions;\n  for (let i = 0, l = selected.length; i < l; i++) {\n    let option = selected[i];\n    array.push(option.value);\n  }\n  return multiple ? array : array[0];\n}\nfunction set_select_values(select, current) {\n  let multiple = select.multiple;\n  let options = select.options;\n  for (let i = 0, l = options.length; i < l; i++) {\n    let option = options[i];\n    let selected = multiple ? current.includes(option.value) : option.value === current;\n    option.selected = selected;\n    if (selected && !multiple) {\n      return;\n    }\n  }\n}\n\nlet _Object = Object;\nlet _Symbol = Symbol;\n\nlet RE_HYPHENATE = /\\B([A-Z])/g;\nlet noop = () => {\n};\nfunction hyphenate(str) {\n  return str.replace(RE_HYPHENATE, \"-$1\").toLowerCase();\n}\nlet is = _Object.is;\nlet assign = _Object.assign;\nlet is_function = (x) => typeof x === \"function\";\nfunction to_number(value) {\n  return value === \"\" ? null : +value;\n}\n\nlet undefined$1;\nlet RUNNING = 1 << 0;\nlet NOTIFIED = 1 << 1;\nlet OUTDATED = 1 << 2;\nlet DISPOSED = 1 << 3;\nlet HAS_ERROR = 1 << 4;\nlet TRACKING = 1 << 5;\nlet eval_scope;\nlet eval_context;\nlet batched_effects;\nlet batch_depth = 0;\nlet batch_iteration = 0;\nlet global_version = 0;\nfunction start_batch() {\n  batch_depth++;\n}\nfunction end_batch() {\n  if (batch_depth > 1) {\n    batch_depth--;\n    return;\n  }\n  let error;\n  let has_error = false;\n  while (batched_effects) {\n    let effects = batched_effects.sort((a, b) => a.i - b.i);\n    let idx = 0;\n    let len = effects.length;\n    batched_effects = undefined$1;\n    batch_iteration++;\n    for (; idx < len; idx++) {\n      let effect2 = effects[idx];\n      effect2.c &= ~NOTIFIED;\n      if (!(effect2.c & DISPOSED) && need_recompute(effect2)) {\n        try {\n          effect2.t();\n        } catch (err) {\n          if (!has_error) {\n            error = err;\n            has_error = true;\n          }\n        }\n      }\n    }\n  }\n  batch_iteration = 0;\n  batch_depth--;\n  if (has_error) {\n    throw error;\n  }\n}\nfunction add_dependency(signal2) {\n  if (!eval_context) {\n    return undefined$1;\n  }\n  let node = signal2.k;\n  if (!node || node.q !== eval_context) {\n    node = {\n      d: 0,\n      n: node,\n      g: signal2,\n      h: eval_context.b,\n      e: undefined$1,\n      q: eval_context,\n      l: undefined$1,\n      j: undefined$1\n    };\n    if (eval_context.b) {\n      eval_context.b.e = node;\n    }\n    eval_context.b = node;\n    signal2.k = node;\n    if (eval_context.c & TRACKING) {\n      signal2.o(node);\n    }\n    return node;\n  } else if (node.d === -1) {\n    node.d = 0;\n    if (node.e) {\n      node.e.h = node.h;\n      if (node.h) {\n        node.h.e = node.e;\n      }\n      node.h = eval_context.b;\n      node.e = undefined$1;\n      eval_context.b.e = node;\n      eval_context.b = node;\n    }\n    return node;\n  }\n  return undefined$1;\n}\nfunction need_recompute(target) {\n  for (let node = target.b; node; node = node.e) {\n    if (node.g.d !== node.d || !node.g.p() || node.g.d !== node.d) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction prepare_sources(target) {\n  for (let node = target.b; node; node = node.e) {\n    let rollback = node.g.k;\n    if (rollback) {\n      node.n = rollback;\n    }\n    node.g.k = node;\n    node.d = -1;\n    if (!node.e) {\n      target.b = node;\n      break;\n    }\n  }\n}\nfunction cleanup_sources(target) {\n  let node = target.b;\n  let head = undefined$1;\n  while (node) {\n    let prev = node.h;\n    if (node.d === -1) {\n      node.g.m(node);\n      if (prev) {\n        prev.e = node.e;\n      }\n      if (node.e) {\n        node.e.h = prev;\n      }\n    } else {\n      head = node;\n    }\n    node.g.k = node.n;\n    if (node.n) {\n      node.n = undefined$1;\n    }\n    node = prev;\n  }\n  target.b = head;\n}\nfunction dispose_effect(effect2) {\n  for (let node = effect2.b; node; node = node.e) {\n    node.g.m(node);\n  }\n  effect2.b = undefined$1;\n}\nfunction end_effect(prev_context) {\n  let _this = this;\n  cleanup_sources(_this);\n  eval_context = prev_context;\n  _this.c &= ~RUNNING;\n  if (_this.c & DISPOSED) {\n    dispose_effect(_this);\n  }\n  end_batch();\n}\nclass Signal {\n  constructor(value) {\n    this.a = value;\n    this.d = 0;\n    this.k = undefined$1;\n    this.f = undefined$1;\n  }\n  p() {\n    return true;\n  }\n  o(node) {\n    let _this = this;\n    if (_this.f !== node && !node.l) {\n      node.j = _this.f;\n      if (_this.f) {\n        _this.f.l = node;\n      }\n      _this.f = node;\n    }\n  }\n  m(node) {\n    let _this = this;\n    if (_this.f) {\n      let prev = node.l;\n      let next = node.j;\n      if (prev) {\n        prev.j = next;\n        node.l = undefined$1;\n      }\n      if (next) {\n        next.l = prev;\n        node.j = undefined$1;\n      }\n      if (node === _this.f) {\n        _this.f = next;\n      }\n    }\n  }\n  subscribe(fn) {\n    let _this = this;\n    return effect(() => {\n      let curr_context = eval_context;\n      let value = _this.value;\n      try {\n        eval_context = undefined$1;\n        fn(value);\n      } finally {\n        eval_context = curr_context;\n      }\n    });\n  }\n  set(next) {\n    return this.value = next;\n  }\n  peek() {\n    let _this = this;\n    return _this.a;\n  }\n  get value() {\n    let _this = this;\n    let node = add_dependency(_this);\n    if (node) {\n      node.d = _this.d;\n    }\n    return _this.a;\n  }\n  set value(next) {\n    let _this = this;\n    if (_this.a !== next) {\n      _this.a = next;\n      _this.d++;\n      global_version++;\n      if (batch_iteration < 100) {\n        start_batch();\n        try {\n          for (let node = _this.f; node; node = node.j) {\n            node.q.r();\n          }\n        } finally {\n          end_batch();\n        }\n      }\n    }\n  }\n}\nclass Computed extends Signal {\n  constructor(compute) {\n    super();\n    this.s = compute;\n    this.b = undefined$1;\n    this.u = global_version - 1;\n    this.c = OUTDATED;\n  }\n  p() {\n    let _this = this;\n    _this.c &= ~NOTIFIED;\n    if (_this.c & RUNNING) {\n      return false;\n    }\n    if ((_this.c & (OUTDATED | TRACKING)) === TRACKING) {\n      return true;\n    }\n    _this.c &= ~OUTDATED;\n    if (_this.u === global_version) {\n      return true;\n    }\n    _this.c |= RUNNING;\n    _this.u = global_version;\n    if (_this.d > 0 && !need_recompute(_this)) {\n      _this.c &= ~RUNNING;\n      return true;\n    }\n    let prev_context = eval_context;\n    try {\n      prepare_sources(_this);\n      eval_context = _this;\n      let value = _this.s();\n      if (_this.c & HAS_ERROR || _this.a !== value || _this.a === 0) {\n        _this.a = value;\n        _this.c &= ~HAS_ERROR;\n        _this.d++;\n      }\n    } catch (err) {\n      _this.a = err;\n      _this.c |= HAS_ERROR;\n      _this.d++;\n    }\n    eval_context = prev_context;\n    cleanup_sources(_this);\n    _this.c &= ~RUNNING;\n    return true;\n  }\n  o(node) {\n    let _this = this;\n    if (!_this.f) {\n      _this.c |= OUTDATED | TRACKING;\n      for (let node2 = _this.b; node2; node2 = node2.e) {\n        node2.g.o(node2);\n      }\n    }\n    super.o(node);\n  }\n  m(node) {\n    let _this = this;\n    if (_this.f) {\n      super.m(node);\n      if (!_this.f) {\n        _this.c &= ~TRACKING;\n        for (let node2 = _this.b; node2; node2 = node2.e) {\n          node2.g.m(node2);\n        }\n      }\n    }\n  }\n  r() {\n    let _this = this;\n    if (!(_this.c & (NOTIFIED | RUNNING))) {\n      _this.c |= OUTDATED | NOTIFIED;\n      for (let node = _this.f; node; node = node.j) {\n        node.q.r();\n      }\n    }\n  }\n  peek() {\n    let _this = this;\n    _this.p();\n    if (_this.c & HAS_ERROR) {\n      throw _this.a;\n    }\n    return _this.a;\n  }\n  get value() {\n    let _this = this;\n    _this.p();\n    if (!(_this.c & RUNNING)) {\n      let node = add_dependency(_this);\n      if (node) {\n        node.d = _this.d;\n      }\n    }\n    if (_this.c & HAS_ERROR) {\n      throw _this.a;\n    }\n    return _this.a;\n  }\n  set value(next) {\n    super.value = next;\n  }\n}\nclass Effect {\n  constructor(compute) {\n    this.s = compute;\n    this.b = undefined$1;\n    this.c = TRACKING;\n    this.i = 0;\n  }\n  t() {\n    let _this = this;\n    if (_this.c & (RUNNING | DISPOSED)) {\n      return;\n    }\n    let finish = _this.v();\n    try {\n      _this.s();\n    } finally {\n      finish();\n    }\n  }\n  v() {\n    let _this = this;\n    _this.c |= RUNNING;\n    _this.c &= ~DISPOSED;\n    cleanup_sources(_this);\n    prepare_sources(_this);\n    start_batch();\n    let prev_context = eval_context;\n    eval_context = _this;\n    return end_effect.bind(_this, prev_context);\n  }\n  r() {\n    let _this = this;\n    if (!(_this.c & (NOTIFIED | RUNNING))) {\n      _this.c |= NOTIFIED;\n      (batched_effects ||= []).push(_this);\n    }\n  }\n  w() {\n    let _this = this;\n    _this.c |= DISPOSED;\n    if (!(_this.c & RUNNING)) {\n      dispose_effect(_this);\n    }\n  }\n}\nclass Scope {\n  constructor(detached) {\n    let _this = this;\n    _this.scopes = [];\n    _this.cleanups = [];\n    _this.parent = undefined$1;\n    _this.i = 0;\n    if (!detached && eval_scope) {\n      _this.parent = eval_scope;\n      _this.i = eval_scope.i + 1;\n      eval_scope.scopes.push(_this);\n    }\n  }\n  run(callback) {\n    let prev_scope = eval_scope;\n    try {\n      eval_scope = this;\n      return callback();\n    } finally {\n      eval_scope = prev_scope;\n    }\n  }\n  clear() {\n    let _this = this;\n    let scopes = _this.scopes;\n    let cleanups = _this.cleanups;\n    for (let scope2 of scopes) {\n      scope2.clear();\n      scope2.parent = undefined$1;\n    }\n    for (let cleanup2 of cleanups) {\n      cleanup2();\n    }\n    scopes.length = 0;\n    cleanups.length = 0;\n  }\n}\nfunction scope(detached) {\n  return new Scope(detached);\n}\nfunction cleanup(callback) {\n  if (is_function(callback) && eval_scope) {\n    eval_scope.cleanups.push(callback);\n  }\n}\nfunction batch(callback) {\n  if (batch_depth > 0) {\n    return callback();\n  }\n  start_batch();\n  try {\n    return callback();\n  } finally {\n    end_batch();\n  }\n}\nfunction untrack(callback) {\n  let prev_context = eval_context;\n  try {\n    eval_context = undefined$1;\n    return callback();\n  } finally {\n    eval_context = prev_context;\n  }\n}\nfunction peek(value) {\n  if (value instanceof Signal) {\n    return value.peek();\n  }\n  return value;\n}\nfunction signal(value) {\n  return new Signal(value);\n}\nfunction computed(compute) {\n  return new Computed(compute);\n}\nfunction effect(compute) {\n  let effect2 = new Effect(compute);\n  let dispose = effect2.w.bind(effect2);\n  try {\n    effect2.t();\n  } catch (error) {\n    dispose();\n    throw error;\n  }\n  if (eval_scope && effect2.b) {\n    effect2.i = eval_scope.i;\n    eval_scope.cleanups.push(dispose);\n  }\n  return dispose;\n}\n\nlet ENABLE_RANDOM_TAGS = false;\nlet RANDOM_TAG = 1;\nfunction use_random_tags() {\n  ENABLE_RANDOM_TAGS = true;\n}\nlet curr_host = null;\nlet default_value = _Symbol();\nclass VelvetComponent extends HTMLElement {\n  $m = false;\n  $c = scope(true);\n  $p = {};\n  $h = [];\n  constructor() {\n    super();\n    let host = this;\n    let props = host.$p;\n    let definition = host.constructor.$d;\n    for (let prop2 in definition) {\n      let index = definition[prop2];\n      props[index] = signal(default_value);\n    }\n  }\n  connectedCallback() {\n    let host = this;\n    if (!host.$m) {\n      host.$m = true;\n      let setup = host.constructor.$c;\n      let styles = host.constructor.$s;\n      let instance = host.$c;\n      let hooks = host.$h;\n      let root = host.shadowRoot;\n      let init_ccss = false;\n      if (!root) {\n        root = host.attachShadow({ mode: \"open\" });\n        init_ccss = true;\n      }\n      let prev_host = curr_host;\n      try {\n        curr_host = host;\n        instance.run(() => setup(root, host));\n        if (document.adoptedStyleSheets) {\n          if (init_ccss) {\n            root.adoptedStyleSheets = styles;\n          }\n        } else {\n          for (let style of styles) {\n            append(root, style.cloneNode(true));\n          }\n        }\n        for (let hook of hooks) {\n          let ret = hook();\n          if (is_function(ret)) {\n            instance.cleanups.push(ret);\n          }\n        }\n        hooks.length = 0;\n      } finally {\n        curr_host = prev_host;\n      }\n    }\n  }\n  disconnectedCallback() {\n    let host = this;\n    if (host.$m) {\n      host.$c.clear();\n      host.shadowRoot.innerHTML = \"\";\n      host.$m = false;\n    }\n  }\n  attributeChangedCallback(attr, prev, next) {\n    let host = this;\n    let mapping = host.constructor.$d;\n    if (attr in mapping) {\n      host.$p[mapping[attr]].value = next === \"\" ? true : next;\n    }\n  }\n}\nfunction define(tag, setup, definition, styles) {\n  let observed_attrs = [];\n  let attr_to_prop = _Object.create(null);\n  class Component extends VelvetComponent {\n    static observedAttributes = observed_attrs;\n    static $c = setup;\n    static $a = attr_to_prop;\n    static $d = definition;\n    static $s = styles;\n  }\n  for (let prop2 in definition) {\n    let index = definition[prop2];\n    let hyphen = hyphenate(prop2);\n    attr_to_prop[hyphen] = prop2;\n    observed_attrs.push(hyphen);\n    _Object.defineProperty(Component.prototype, prop2, {\n      get() {\n        return this.$p[index].a;\n      },\n      set(next) {\n        this.$p[index].value = next;\n      }\n    });\n  }\n  if (ENABLE_RANDOM_TAGS) {\n    tag = \"velvet-\" + RANDOM_TAG++;\n  }\n  if (tag) {\n    customElements.define(tag, Component);\n  }\n  return Component;\n}\nfunction css(text) {\n  if (!document.adoptedStyleSheets) {\n    const style2 = document.createElement(\"style\");\n    style2.textContent = text;\n    return style2;\n  }\n  const style = new CSSStyleSheet();\n  style.replaceSync(text);\n  return style;\n}\nfunction prop(index, value) {\n  let state = curr_host.$p[index];\n  if (state.value === default_value) {\n    state.value = is_function(value) ? value() : value;\n  }\n  return state;\n}\nfunction on_mount(fn) {\n  if (is_function(fn)) {\n    curr_host.$h.push(fn);\n  }\n}\nfunction event_dispatcher() {\n  let host = curr_host;\n  return (type, detail) => {\n    let event = new CustomEvent(type, { detail, bubbles: false });\n    host.dispatchEvent(event);\n  };\n}\nfunction bind(obj) {\n  assign(curr_host, obj);\n}\nfunction use(node, action, getter) {\n  let ref = getter && computed(getter);\n  let instance = action(node, ref && ref.value);\n  if (!instance) {\n    return;\n  }\n  if (is_function(instance.destroy)) {\n    cleanup(() => instance.destroy());\n  }\n  if (ref && ref.b && is_function(instance.update)) {\n    let init = false;\n    effect(() => {\n      let next = ref.value;\n      if (!init) {\n        init = true;\n        return;\n      }\n      instance.update(next);\n    });\n  }\n}\n\nlet event_name = \"context-request\";\nfunction provide(key, value) {\n  let listener = (event) => {\n    if (event.context === key) {\n      event.stopImmediatePropagation();\n      event.callback(value, null);\n    }\n  };\n  on(curr_host, event_name, listener);\n}\nfunction inject(key, def) {\n  let value = def;\n  let callback = (next, dispose) => {\n    dispose?.();\n    value = next;\n  };\n  let event = new ContextEvent(key, callback, false);\n  curr_host.dispatchEvent(event);\n  return value;\n}\nclass ContextEvent extends Event {\n  constructor(context, callback, multiple) {\n    super(event_name, { bubbles: true, composed: true });\n    this.context = context;\n    this.callback = callback;\n    this.multiple = multiple;\n  }\n}\n\nexport { default_value as A, define as B, ContextEvent as C, css as D, Effect as E, prop as F, bind as G, use as H, html as I, create as J, clone as K, traverse as L, after as M, on as N, toggle as O, attr as P, attr_ifdef as Q, class_toggle as R, Scope as S, style_set as T, get_checked_values as U, VelvetComponent as V, get_select_values as W, set_select_values as X, Signal as a, effect as b, computed as c, batch as d, event_dispatcher as e, untrack as f, peek as g, scope as h, inject as i, cleanup as j, append as k, eval_scope as l, remove_parts as m, is as n, on_mount as o, provide as p, noop as q, replace as r, signal as s, hyphenate as t, use_random_tags as u, assign as v, is_function as w, to_number as x, Computed as y, curr_host as z };\n", "const RAND_MAX = 0xFFFF_FFFF_FFFF;\nconst RAND_CACHE = new Uint8Array(6 * 1024);\n\nlet RAND_OFFSET  = RAND_CACHE.length;\n\n/**\n * @param {PasswordGenerationOptions} options\n * @returns {string}\n */\nexport function generatePassword (options) {\n\tconst positions = [];\n\n\tfor (let i = 0, l = options.lowercase; i < l; i++) {\n\t\tpositions.push('l');\n\t}\n\n\tfor (let i = 0, l = options.uppercase; i < l; i++) {\n\t\tpositions.push('u');\n\t}\n\n\tfor (let i = 0, l = options.number; i < l; i++) {\n\t\tpositions.push('n');\n\t}\n\n\tfor (let i = 0, l = options.special; i < l; i++) {\n\t\tpositions.push('s');\n\t}\n\n\tfor (let i = positions.length; i < options.length; i++) {\n\t\tpositions.push('r');\n\t}\n\n\tshuffle(positions);\n\n\tlet charset = '';\n\n\tlet lowercaseCharset = 'abcdefghijkmnopqrstuvwxyz';\n\tlet uppercaseCharset = 'ABCDEFGHJKLMNPQRSTUVWXYZ';\n\tlet numberCharset = '23456789';\n\tlet specialCharset = '!@#$%^&*()_+-=.';\n\n\tif (options.ambiguous) {\n\t\tlowercaseCharset += 'l';\n\t\tuppercaseCharset += 'IO';\n\t\tnumberCharset += '10';\n\t}\n\n\tif (options.lowercase > -1) {\n\t\tcharset += lowercaseCharset;\n\t}\n\n\tif (options.uppercase > -1) {\n\t\tcharset += uppercaseCharset;\n\t}\n\n\tif (options.number > -1) {\n\t\tcharset += numberCharset;\n\t}\n\n\tif (options.special > -1) {\n\t\tcharset += specialCharset;\n\t}\n\n\tlet password = '';\n\n\tfor (let idx = 0; idx < positions.length; idx++) {\n\t\tlet selectedCharset;\n\n\t\tswitch (positions[idx]) {\n\t\t\tcase 'l':\n\t\t\t\tselectedCharset = lowercaseCharset;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tselectedCharset = uppercaseCharset;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tselectedCharset = numberCharset;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tselectedCharset = specialCharset;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tselectedCharset = charset;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpassword += selectedCharset[randrange(0, selectedCharset.length)];\n\t}\n\n\treturn password;\n}\n\n/**\n * https://stackoverflow.com/a/12646864\n * @param {any[]} array\n */\nfunction shuffle (array) {\n\tfor (let i = array.length - 1; i > 0; i--) {\n\t\tconst j = randrange(0, i);\n\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * @param {number} min\n * @param {number} max\n * @returns {number}\n */\nfunction randrange (min, max) {\n\tconst range = max - min;\n\n\tif (range <= 0) {\n\t\treturn min;\n\t}\n\n\tconst limit = RAND_MAX - (RAND_MAX % range);\n\n\twhile (true) {\n\t\tif (RAND_OFFSET === RAND_CACHE.length) {\n\t\t\tcrypto.getRandomValues(RAND_CACHE);\n\t\t\tRAND_OFFSET = 0;\n\t\t}\n\n\t\tconst x = readUInt48BE(RAND_CACHE, RAND_OFFSET);\n\t\tRAND_OFFSET += 6;\n\n\t\tif (x < limit) {\n\t\t\treturn (x % range) + min;\n\t\t}\n\t}\n}\n\n/**\n * @param {Uint8Array} buffer\n * @param {number} offset\n * @returns {number}\n */\nfunction readUInt48BE (buffer, offset = 0) {\n\tconst first = buffer[offset];\n\tconst last = buffer[offset + 5];\n\n\treturn (\n\t\t(first * 2 ** 8 + buffer[++offset]) * 2 ** 32 + buffer[++offset] * 2 ** 24 +\n\t\tbuffer[++offset] * 2 ** 16 + buffer[++offset] * 2 ** 8 + last\n\t);\n}\n\n/**\n * @typedef {object} PasswordGenerationOptions\n * @property {number} length Password length\n * @property {number} lowercase Include lowercase characters\n * @property {number} uppercase Include uppercase characters\n * @property {number} number Include number characters\n * @property {number} special Include special characters\n * @property {boolean} ambiguous Include potentially ambiguous characters\n */\n", "import {signal, html, clone, traverse, effect, attr, on, to_number, append, css, define} from \"@intrnl/velvet/internal\";\nimport {generatePassword} from './generator.js';\nimport '~/style.css';\nlet template0 = html(\"<h3>random password generator</h3><form><div class=password><input readonly><button type=button>copy</button><button type=submit>generate</button></div><hr><label><span>length</span> <input required type=number min=1></label><label><span>lowercase</span> <input required type=number min=-1></label><label><span>uppercase</span> <input required type=number min=-1></label><label><span>number</span> <input required type=number min=-1></label><label><span>special</span> <input required type=number min=-1></label><label><span>ambiguous</span> <input type=checkbox></label><hr><p><a target=_blank href=https://codeberg.org/intrnl/random-password-generator> source code </a></p></form>\");\nlet style0 = css(\"*,*:before,*:after{box-sizing:border-box}h3,form,label{margin-top:0;margin-bottom:16px}h3,form{display:block}label{display:flex;align-items:center;justify-content:space-between}label>span{display:block;margin-bottom:4px;flex-grow:1}input,button{padding:8px;height:36px}input{font-family:monospace}.password{display:flex;gap:8px}.password input{width:-moz-available;width:-webkit-fill-available;width:fill-available}hr{color:transparent;border:0;border-bottom:1px solid #808080;margin:16px 0}a{text-decoration:none}a:hover{text-decoration:underline}\");\nfunction setup($$root, $$host) {\n  let length = signal(16);\n  let lowercase = signal(1);\n  let uppercase = signal(1);\n  let number = signal(1);\n  let special = signal(1);\n  let ambiguous = signal(false);\n  let password = signal('');\n  let textfield = signal();\n  function generate(ev) {\n    if (ev) {\n      ev.preventDefault();\n    }\n    password.value = generatePassword({\n      length: length.value,\n      lowercase: lowercase.value,\n      uppercase: uppercase.value,\n      number: number.value,\n      special: special.value,\n      ambiguous: ambiguous.value\n    });\n  }\n  function copy() {\n    textfield.value.select();\n    document.execCommand('copy');\n  }\n  generate();\n  let fragment0 = clone(template0);\n  let child0 = traverse(fragment0, [1, 0, 0]);\n  let child1 = traverse(fragment0, [1, 0, 1]);\n  let child2 = traverse(fragment0, [1, 2, 2]);\n  let child3 = traverse(fragment0, [1, 3, 2]);\n  let child4 = traverse(fragment0, [1, 4, 2]);\n  let child5 = traverse(fragment0, [1, 5, 2]);\n  let child6 = traverse(fragment0, [1, 6, 2]);\n  let child7 = traverse(fragment0, [1, 7, 2]);\n  let child8 = traverse(fragment0, [1]);\n  effect(() => attr(child0, \"value\", password.value));\n  textfield.value = child0;\n  on(child1, \"click\", copy);\n  effect(() => child2[\"value\"] = length.value);\n  on(child2, \"input\", () => length.value = to_number(child2.value));\n  effect(() => child3[\"value\"] = lowercase.value);\n  on(child3, \"input\", () => lowercase.value = to_number(child3.value));\n  effect(() => child4[\"value\"] = uppercase.value);\n  on(child4, \"input\", () => uppercase.value = to_number(child4.value));\n  effect(() => child5[\"value\"] = number.value);\n  on(child5, \"input\", () => number.value = to_number(child5.value));\n  effect(() => child6[\"value\"] = special.value);\n  on(child6, \"input\", () => special.value = to_number(child6.value));\n  effect(() => child7[\"checked\"] = ambiguous.value);\n  on(child7, \"input\", () => ambiguous.value = child7.checked);\n  on(child8, \"submit\", generate);\n  append($$root, fragment0);\n}\nexport default define(\"x-app\", setup, {}, [style0]);\n"],
  "mappings": "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",
  "names": ["html", "fragment", "is_wrapped", "node", "content", "wrapper", "child", "clone", "template", "traverse", "node", "indices", "ref", "i", "il", "x", "j", "append", "ref", "node", "on", "node", "type", "listener", "options", "attr", "node", "name", "value", "_Object", "_Symbol", "RE_HYPHENATE", "hyphenate", "str", "RE_HYPHENATE", "is", "_Object", "assign", "is_function", "x", "to_number", "value", "undefined$1", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "eval_scope", "eval_context", "batched_effects", "batch_depth", "batch_iteration", "global_version", "start_batch", "end_batch", "error", "has_error", "effects", "a", "b", "idx", "len", "effect2", "need_recompute", "err", "add_dependency", "signal2", "node", "target", "prepare_sources", "rollback", "cleanup_sources", "head", "prev", "dispose_effect", "end_effect", "prev_context", "_this", "Signal", "next", "fn", "effect", "curr_context", "Effect", "compute", "undefined$1", "TRACKING", "_this", "RUNNING", "DISPOSED", "finish", "cleanup_sources", "prepare_sources", "start_batch", "prev_context", "eval_context", "end_effect", "NOTIFIED", "batched_effects", "dispose_effect", "Scope", "detached", "eval_scope", "callback", "prev_scope", "scopes", "cleanups", "scope2", "cleanup2", "scope", "signal", "value", "Signal", "effect", "compute", "effect2", "Effect", "dispose", "error", "eval_scope", "ENABLE_RANDOM_TAGS", "RANDOM_TAG", "curr_host", "default_value", "_Symbol", "VelvetComponent", "scope", "host", "props", "definition", "prop2", "index", "signal", "setup", "styles", "instance", "hooks", "root", "init_ccss", "prev_host", "style", "append", "hook", "ret", "is_function", "attr", "prev", "next", "mapping", "define", "tag", "observed_attrs", "attr_to_prop", "_Object", "Component", "hyphen", "hyphenate", "ENABLE_RANDOM_TAGS", "RANDOM_TAG", "css", "text", "style2", "RAND_CACHE", "RAND_OFFSET", "generatePassword", "options", "positions", "i", "l", "shuffle", "charset", "lowercaseCharset", "uppercaseCharset", "numberCharset", "specialCharset", "password", "idx", "selectedCharset", "randrange", "array", "j", "temp", "min", "max", "range", "limit", "x", "readUInt48BE", "buffer", "offset", "first", "last", "template0", "html", "style0", "css", "setup", "$$root", "$$host", "length", "signal", "lowercase", "uppercase", "number", "special", "ambiguous", "password", "textfield", "generate", "ev", "generatePassword", "copy", "fragment0", "clone", "child0", "traverse", "child1", "child2", "child3", "child4", "child5", "child6", "child7", "child8", "effect", "attr", "on", "to_number", "append", "App_default", "define"]
}
